## ES6之let与const语法

> var太不严谨了，所以引入了let和const更规范一点；
>
> let是变量，const是常量；

### let命令

> 等价于var，用于声明变量，不过let声明的变量只能在其所在的代码块内有效。

> ```js
> {
>   let a = 10;
>   var b = 1;
> }
> a // ReferenceError: a is not defined.
> b // 1
> ```
>
> 如上，同样是声明变量，let只在代码块内有效；var有变量提升，作用域宽泛，很麻烦。
>
> 显然，let更符合我们的编码习惯，并且更规范一点。

> 一个经典的问题：计数器的问题
>
> ```js
> var a = [];
> for (var i = 0; i < 10; i++) {
>   a[i] = function () {
>     console.log(i);
>   };
> }
> a[6](); // 10
> ```
>
> ```js
> var a = [];
> for (let i = 0; i < 10; i++) {
>   a[i] = function () {
>     console.log(i);
>   };
> }
> a[6](); // 6
> ```
>
> 用var的情况下，变量i是全局的i，a数组里面所有的i指向的都是全局的同一个i，所以最后得到的输出是10；
>
> 用let的情况下，变量i只在块级作用域内有效，每次循环都是新的i，相互独立，所以最后得到的输出是6；

> 另外，`for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域.
>
> ```js
> for (let i = 0; i < 3; i++) {
>   let i = 'abc';
>   console.log(i);
> }
> // abc
> // abc
> // abc
> ```
>
> 上面代码正确运行，输出了 3 次`abc`。这表明函数内部的变量`i`与循环变量`i`不在同一个作用域，有各自单独的作用域。

---

- 不存在变量提升

> `var`命令会发生“变量提升”现象，即变量可以在声明之前使用，值为`undefined`。
>
> 这个就太宽松了，奇奇怪怪的，也不符合我们的编码习惯。

> 所以，let就不存在变量提升了，即要先声明再使用。
>
> ```js
> // var 的情况
> console.log(foo); // 输出undefined
> var foo = 2;
> 
> // let 的情况
> console.log(bar); // 报错ReferenceError
> let bar = 2;
> ```
>
> var有变量提升，所以foo存在，输出undefined；
>
> let没有变量提升，bar不存在，所以报错。

---

- 暂时性死区

> 只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

> ```javascript
> var tmp = 123;
> 
> if (true) {
>   tmp = 'abc'; // ReferenceError
>   let tmp;
> }
> ```
>
> 如上，全局有一个tmp变量，块级作用域中又声明了一个tmp变量，后者绑定了这个块级作用域，
>
> 所以，在let声明之前使用变量，会报错。

> 同样的语法同样适用const，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
>
> 在代码块内，声明变量之前，变量不可用。这在语法上，叫做“暂时性死区”。

> **暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。**

---

- ### 不允许重复声明

> `let`不允许在相同作用域内，重复声明同一个变量。
>
> ```js
> // 报错
> function func() {
>   let a = 10;
>   var a = 1;
> }
> // 报错
> function func() {
>   let a = 10;
>   let a = 1;
> }
> ```
>
> 这个没什么说的，符合我们的思维习惯。

---

### 块级作用域

> ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

> 第一种场景，内层变量可能会覆盖外层变量。
>
> ```javascript
> var tmp = new Date();
> 
> function f() {
>   console.log(tmp);
>   if (false) {
>     var tmp = 'hello world';
>   }
> }
> 
> f(); // undefined
> ```
>
> var的变量提升导致tmp的输出为undefined，内层变量覆盖了外层变量；

> 第二种场景，用来计数的循环变量泄露为全局变量。
>
> 还是那个经典问题
>
> ```js
> var s = 'hello';
> for (var i = 0; i < s.length; i++) {
>   console.log(s[i]);
> }
> 
> console.log(i); // 5
> ```
>
> 变量i变成了全局变量，输出5；

---

> `ES6`加入了块级作用域
>
> ```js
> function f1() {
>   let n = 5;
>   if (true) {
>     let n = 10;
>   }
>   console.log(n); // 5
> }
> ```
>
> 如上，因为存在块级作用域，输出5。
>
> - ES6 允许块级作用域的任意嵌套。
>
> ```js
> {{{{
>   {let insane = 'Hello World'}
>   console.log(insane); // 报错
> }}}};
> ```
>
> - 内层作用域可以定义外层作用域的同名变量
>
> ```js
> {{{{
>   let insane = 'Hello World';
>   {let insane = 'Hello World'}
> }}}};
> ```
>
> 

- ### 块级作用域与函数声明

> ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

---

### const 命令 

> `const`声明一个只读的常量。一旦声明，常量的值就不能改变。

> `const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。

> `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

> `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

> `const`声明的常量，也与`let`一样不可重复声明。

- 本质

> `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
>
> ```js
> const foo = {};
> 
> // 为 foo 添加一个属性，可以成功
> foo.prop = 123;
> foo.prop // 123
> 
> // 将 foo 指向另一个对象，就会报错
> foo = {}; // TypeError: "foo" is read-only
> ```
>
> ```js
> const a = [];
> a.push('Hello'); // 可执行
> a.length = 0;    // 可执行
> a = ['Dave'];    // 报错
> ```
>
> 

---

- ### ES6 声明变量的六种方法

> `var`命令和`function`命令；`let`和`const`命令；另外两种声明变量的方法：`import`命令和`class`命令。
>
> 一共六种方法。

### 顶层对象的属性

> 顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。ES5 之中，顶层对象的属性与全局变量是等价的。
>
> ```js
> window.a = 1;
> a // 1
> 
> a = 2;
> window.a // 2
> ```
>
> 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。

> 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

> **在ES5中，顶层对象的属性和全局变量等价是败笔；**
>
> **这样做，编译的时候区分不出来变量是否未声明；个人失误导致全局变量；模块化问题；混在一起造成问题。**

> ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
>
> ```js
> var a = 1;
> // 如果在 Node 的 REPL 环境，可以写成 global.a
> // 或者采用通用方法，写成 this.a
> window.a // 1
> 
> let b = 1;
> window.b // undefined
> ```
>
> 

---

> **做个总结：**
>
> 也没什么说的，let和const，一个声明变量，一个声明常量；
>
> 在使用的过程中更符合我们的思维习惯了；
>
> 引入了块级作用域等概念；
>
> 更规范了，原语法同样保留，可以兼容，推荐用新的语法。