---
typora-root-url: img
---

## react学习笔记之React哲学

> 这一块也很重要，主要是讲一个react应用的搭建过程推荐使用什么样的理念和流程来做；
>
> 不同的框架有自己不同的特性，在开发应用的过程中，又有很多的差异；
>
> 官方的推荐文档就是结合自己的特性给出的最优的开发方式；
>
> 所以说这一块很重要。

> 下面是官方给的一个例子，通过例子来介绍react应用的整个设计过程

### 从设计稿开始

> 假设我们已经有了一个返回 JSON 的 API，以及设计师提供的组件设计稿。如下所示：
>
> ![设计稿](/设计稿.png)
>
> 该 JSON API 会返回以下数据：
>
> ```js
> [
>   {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
>   {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
>   {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
>   {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
>   {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
>   {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
> ];
> ```
>
> 

### 第一步：将设计好的 UI 划分为组件层级

> **先说一下我的理解：**
>
> 我们拿到了设计图，确实是需要先针对设计图进行划分，层级的划分；
>
> 划分的目的当然是为了设计组件，以及清楚组件之间的包含关系；
>
> 划分原则是单一功能原则；
>
> 划分如果划分的好，能省去很多的麻烦。

> 首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 Photoshop 的图层名称可能最终就是你编写的 React 组件的名称！
>
> 但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据[单一功能原则](https://en.wikipedia.org/wiki/Single_responsibility_principle)来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。
>
> 在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的*信息结构*。因此，将用户界面划分为组件的工作量就可以忽略不计了。只需使组件完全对应地展现数据模型的某部分即可。
>
> ![设计稿第一步](/设计稿第一步.png)
>
> 你会看到我们的简单应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。
>
> 1. **FilterableProductTable (橙色):** 是整个示例应用的整体
> 2. **SearchBar (蓝色):** 接受所有的*用户输入*
> 3. **ProductTable (绿色):** 展示*数据内容*并根据*用户输入*筛选结果
> 4. **ProductCategoryRow (天蓝色):** 为每一个*产品类别*展示标题
> 5. **ProductRow (红色):** 每一行展示一个*产品*
>
> 你可能注意到，`ProductTable` 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。就这个示例而言，因为表头只起到了渲染*数据集合*的作用——这与 `ProductTable` 是一致的，所以我们仍然将其保留为 `ProductTable` 的一部分。但是，如果表头过于复杂（比如我们需为其添加排序功能），那么将它作为一个独立的 `ProductTableHeader` 组件就显得很有必要了。
>
> 现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。
>
> - `FilterableProductTable`
>   - `SearchBar`
>   - `ProductTable`
>     - `ProductCategoryRow`
>     - `ProductRow`

### 第二步：用 React 创建一个静态版本

> **我的理解**
>
> 怎么说的，创建静态版本的目的是把界面和数据分成两步来处理；
>
> 而创建静态版本就是让你只关注界面，数据简单过一下就好；
>
> 我们都知道做一件事最好的方法是能梳理清楚做这件事的流程，知道自己完成了多少，还剩余多少没做；
>
> 其实我在实际的开发过程中也遇到了数据方面的问题，数据的取舍让我很纠结；
>
> 这个步骤是为了让关注点分离，方便开发。

> 现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。
>
> 在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 *props* 传入所需的数据。*props* 是父组件向子组件传递数据的方式。即使你已经熟悉了 *state* 的概念，也**完全不应该使用 state** 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。
>
> 你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 `FilterableProductTable`），自下而上意味着从最基本的组件开始编写（比如 `ProductRow`）。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。
>
> 到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 `render()` 方法用于渲染。最顶层的组件 `FilterableProductTable` 通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 `ReactDOM.render()`，UI 就会相应地被更新。数据模型变化、调用 `render()` 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React **单向数据流**（也叫*单向绑定*）的思想使得组件模块化，易于快速开发。

### 第三步：确定 UI state 的最小（且完整）表示

> **我的理解**
>
> 这个就是我说的数据的抉择问题，是props还是state；
>
> state判断的标准推荐是三个问题：是否来自父组件；是否可变；是否可计算；
>
> 如上，这一步是为了确定数据里面的state。

> 想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过 **state** 来完成这个任务。
>
> 为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 `Don’t Repeat Yourself`。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。
>
> 我们的示例应用拥有如下数据：
>
> - 包含所有产品的原始列表
> - 用户输入的搜索词
> - 复选框是否选中的值
> - 经过搜索筛选的产品列表
>
> 通过问自己以下**三个问题**，你可以逐个检查相应数据是否属于 state：
>
> 1. 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
> 2. 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
> 3. 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
>
> 包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。
>
> 综上所述，属于 state 的有：
>
> - 用户输入的搜索词
> - 复选框是否选中的值

### 第四步：确定 state 放置的位置

> **我的理解**
>
> 如果上一步确定了state的数据表示范围，当然是越小越好；
>
> 这一步就是确定state的位置，放在哪个组件里；
>
> 官方文档说的很对，这一步**对于初学者来说确实是最难理解的部分**；
>
> 其实我细想一下，我觉得找到state的位置也不是很难的事情（找最小公倍数的感觉），难的是数据的流向和传输的问题；
>
> 我们都知道react是自上向下的数据流向，那么从下往上、同级组件、跨级、动态同步又涉及到比较复杂的处理方式了，所以我认为难的是这里。

> 我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说*拥有*这些 state。
>
> 注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，**对初学者来说往往是最难理解的部分**。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：
>
> 对于应用中的每一个 state：
>
> - 找到根据这个 state 进行渲染的所有组件。
> - 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
> - 该共同所有者组件或者比它层级更高的组件应该拥有该 state。
> - 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
>
> 根据以上策略重新考虑我们的示例应用：
>
> - `ProductTable` 需要根据 state 筛选产品列表。`SearchBar` 需要展示搜索词和复选框的状态。
> - 他们的共同所有者是 `FilterableProductTable`。
> - 因此，搜索词和复选框的值应该很自然地存放在 `FilterableProductTable` 组件中。
>
> 很好，我们已经决定把这些 state 存放在 `FilterableProductTable` 组件中。首先，将实例属性 `this.state = {filterText: '', inStockOnly: false}` 添加到 `FilterableProductTable`的 `constructor` 中，设置应用的初始 state；接着，将 `filterText` 和 `inStockOnly` 作为 props 传入 `ProductTable` 和 `SearchBar`；最后，用这些 props 筛选 `ProductTable` 中的产品信息，并设置 `SearchBar` 的表单值。
>
> 你现在可以看到应用的变化了：将 `filterText` 设置为 `"ball"` 并刷新应用，你能发现表格中的数据已经更新了。

### 第五步：添加反向数据流

> **我的理解**
>
> 说曹操曹操到，反向数据流；
>
> 自上而下很好弄，属性传值，props取值；
>
> 反向数据流就涉及到很多的情况了，这里官方文档给出了一个最基本最常用的反向情况；
>
> 通过回调函数的形式，让父组件知道子组件的变化，从而执行相应的程序；
>
> 我在想，如果是不复杂的情况，一切还好，如果层级很多，大家相互之间都有影响，搞起来就不那么友好了，当然嘛，react还是给出了很多的解决方案，用来应对不同的情况；
>
> 对此，我想说：**革命尚未成功，我还需努力**。

> 到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的 `FilterableProductTable` 中的 state。
>
> React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更利于人们理解程序的运作方式。
>
> 如果你在这时尝试在搜索框输入或勾选复选框，React 不会产生任何响应。这是正常的，因为我们之前已经将 `input` 的值设置为了从 `FilterableProductTable` 的 `state` 传递而来的固定值。
>
> 让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。由于 state 只能由拥有它们的组件进行更改，`FilterableProductTable` 必须将一个能够触发 state 改变的回调函数（callback）传递给 `SearchBar`。我们可以使用输入框的 `onChange` 事件来监视用户输入的变化，并通知 `FilterableProductTable` 传递给 `SearchBar`的回调函数。然后该回调函数将调用 `setState()`，从而更新应用。
>
> 尽管描述起来有点复杂，但实际上只是几行代码而已。你可以清楚地看到你的应用中数据是如何流动的。