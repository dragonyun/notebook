## 考试题目资料

1、web应用如何配置Spring；

> 

2、如何防止sql注入；

> **不要使用动态SQL**
>
> 避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。
>
> **不要将敏感数据保留在纯文本中**
>
> 加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。
>
> **限制数据库权限和特权**
>
> 将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。
>
> **避免直接向用户显示数据库错误**
>
> 攻击者可以使用这些错误消息来获取有关数据库的信息。
>
> **对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）**
>
> 这为面向Web的应用程序提供了保护，它可以帮助识别SQL注入尝试；根据设置，它还可以帮助防止SQL注入尝试到达应用程序（以及数据库）。
>
> **定期测试与数据库交互的Web应用程序**
>
> 这样做可以帮助捕获可能允许SQL注入的新错误或回归。
>
> **将数据库更新为最新的可用修补程序**
>
> 这可以防止攻击者利用旧版本中存在的已知弱点/错误。

3、数据库连接池机制是什么；

> ###### JavaEE服务器启动时，就会创建一定数量的池连接，并且会一直维护不少于此数目的连接。当客户端程序需要连接时，池驱动程序会返回一个未使用的连接给客户，并把这个连接标记为忙，如果当前没有空闲的连接，池驱动程序就会创建新建一定数量的新的连接，新建连接的数量由配置参数决定。
>
> 当使用的池连接被调用完后，池驱动程序将次连接标记为空闲，其他程序就可以调用这个连接了。

4、hello.war包和test目录如何分别部署到XXXServer上，如何判断war包部署成功，如何查看；

> 文件通过ftp软件传到服务器上
>
> 将projectName.war包，复制到Tomcat的webapp下，
>
> 修改tomcat服务器配置文件，
>
> 首先运行Tomcat的bin目录下的startup.bat，当Tomcat启动完毕后，
>
> 在浏览器输入：localhost:8080/projectName/login.jsp时，如果出现该Web项目的login界面时，则表明war包已成功地部署到tomcat服务器上，并可成功访问了。

5、M、V、C分别指什么；

> M：model模型层；V：view视图层；C：controller控制层

6、String、StringBuilder、StringBuffer的区别；

> String是字符串常量；后两个是字符串变量；
>
> 三者在执行速度方面的比较：**StringBuilder >  StringBuffer  >  String** 
>
> StringBuilder：线程非安全的，StringBuffer：线程安全的，多线程用StringBuilder不保证安全；
>
> 不过我们大多数情况下在单线程操作，所以常见的是StringBuilder
>
> 总结：
>
> 1.如果要操作少量的数据用 = String　　
>
> 2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
>
> 3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

7、sleep();wait()的区别；

> ### sleep
>
> - 让当前线程休眠指定时间。
> - 休眠时间的准确性依赖于系统时钟和CPU调度机制。
> - 不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进入到当前同步块或者同步方法中的。
> - 可通过调用interrupt()方法来唤醒休眠线程。
>
> ### wait
>
> - 让当前线程进入等待状态，当别的其他线程调用notify()或者notifyAll()方法时，当前线程进入就绪状态
> - wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，前提是必须获取对象上的锁资源
> - 当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。 
>
> |            | wait                                                         | sleep                                             |
> | ---------- | ------------------------------------------------------------ | ------------------------------------------------- |
> | 同步       | 只能在同步上下文中调用wait方法，否则或抛出IllegalMonitorStateException异常 | 不需要在同步方法或同步块中调用                    |
> | 作用对象   | wait方法定义在Object类中，作用于对象本身                     | sleep方法定义在java.lang.Thread中，作用于当前线程 |
> | 释放锁资源 | 是                                                           | 否                                                |
> | 唤醒条件   | 其他线程调用对象的notify()或者notifyAll()方法                | 超时或者调用interrupt()方法体                     |
> | 方法属性   | wait是实例方法                                               | sleep是静态方法                                   |

8、用户访问应用404，jboss应用和端口都正常，可能是什么原因产生的，如何排查；

> 查看中间件进程；
>
> 机器状态查看；
>
> 查看服务器监听端口；

9、用java8聚合编程，对personList按照性别男、年龄范围在22-30，年龄升序打印出personlist里面的人员名称

---

1. J2EE的常用设计模式，说明一下工厂模式

> 总共23种，分为三大类：创建型，结构型，行为型
> 我只记得其中常用的6、7种，分别是：
> 创建型（工厂、工厂方法、抽象工厂、单例）
> 结构型（包装、适配器，组合，代理）
> 行为（观察者，模版，策略）
> 然后再针对你熟悉的模式谈谈你的理解即可。
>
> Java中的23种设计模式：
> Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），
> Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），
> Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），
> Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），
> Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），
> Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），
> Observer（观察者模式）， State（状态模式）， Strategy（策略模式），
> Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）
>
> 工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。

1. Thread.sleep() 和 Object.wait() 有啥作用？

> 1、这两个方法来自**不同的类**分别是，sleep来自Thread类，和wait来自Object类。
>
> sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。
>
> 2、**最主要**是sleep方法没有**释放锁**，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
>
> sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。
>
> Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。
> 3、**使用范围：**wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
>    synchronized(x){ 
>       x.notify() 
>      //或者wait() 
>    }
> 4、sleep必须**捕获异常**，而wait，notify和notifyAll不需要捕获异常

1. 常用的集合，并说明使用场景   √
2. JSP的动态INCLUDE 和静态INCLUDE的差别

>   **动态INCLUDE** 
>
> 用法：<jsp:include page="included.jsp" flush="true" /> 
>
> 说明：它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数，先编译之后再进行处理。 
>
> 原因：1、静态include的结果是把其他jsp引入当前jsp,两者合为一体。 
>
> 2、静态include纯粹是把代码写在外面的一种共享方法,所有的变量都是可以和include它的主文件共享,两者高度紧密结合,不能有变量同名的冲突.而页面设置也可以借用主文件的. 
>
> **静态INCLUDE** 
>
> 用法：<%@ include file="included.htm" %> 
>
> 说明：用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面，直接将内容先包含后处理。 
>
> 原因：1、动态include的结构是两者独立,直到输出时才合并( 看看jsp生成的java文件就可以知道了)。 
>
> 2、动态include的jsp文件独立性很强,是一个单独的jsp文件,需要使用的对象,页面设置,都必须有自己创建,当然,还好它和include它的页面的request范围是一致的。  

1. 线程的概念，线程的状态

> 线程：是进程中的一个执行控制单元，执行路径
>
>       一个进程中至少有一个线程在负责控制程序的执行
>     
>       一个进程中如果只有一个执行路径，这个程序称为单线程
>     
>       一个进程中有多个执行路径时，这个程序成为多线程
>
> 一个线程是进程的一个顺序执行流。同类的多个线程共享一块内存空间和一组系统资源，线程本身有一个供程序执行时的堆栈。线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。
>
> 在JVM内存模型中，线程开辟在栈中，有些前辈称之为方法的栈帧，对于这个栈帧空间就是一个线程空间，也就是一个进程调用了一个方法，这个方法在栈中就开辟一个空间，也可以认为是线程的空间，当该方法结束后，该线程就结束，但进程还在继续执行，还会继续执行接下来的方法，继续开辟线程。。。
>
> 
>
> 线程与进程区别
>
> 一个进程有一个或多个线程。线程更细化于进程，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
>
> 线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
>
> 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配。
>
>
> 线程状态
> 1.新建
>
> new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。
>
> 2.等待
>
> 当线程在new之后，并且在调用start方法前，线程处于等待状态。
>
> 3.就绪
>
> 当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程位于Java虚拟机的可运行池中，等待cpu的使用权。
>
> 4.运行状态
>
> 处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。
>
> 只有处于就绪状态的线程才有机会转到运行状态。
>
> 5.阻塞状态
>
> 阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。
>
> 阻塞状态分为三种:
>
> 1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。
>
> 2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。
>
> 3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。
>
> 6.死亡状态
>
> 当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。

1. final、finally、finalize的作用   √
2. 方法重载和方法覆盖的区别   √

---

1. FILE类实现递归打印文件名   √

> ```js
> import java.io.File;  
> import java.io.IOException;  
>   
> public class Demo {  
>     public static void main(String[] args) {  
>         try {  
>             FilesUtil.ListFiles(new File("Pathname")); //创建路径名称  
>         } catch (Exception e) {  
>             e.printStackTrace();  
>         }  
>     }  
> }  
>   
> class FilesUtil {  
>     public static void ListFiles (File dir) throws IOException {  
>         File[] names = dir.listFiles();   
>         if (names != null && names.length > 0) {  
>             for (File name : names) {  
>                 if (name.isDirectory())  
>                     ListFiles(name); // 递归，若是文件夹，继续调用方法  
>                 else   
>                     System.out.println(name.getName()); // 递归基准，若是文件,则打印文件名称  
>             }      
>         }  
>     }   
> }  
> ```
>
> 

1. 数据库查询代码块异常查找，并写出修复伪代码    √
2. Jboss相关配置填空
3. 工作窃取(work-stealing)的工作原理

> 工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。
>
> 一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并未每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如线程1负责处理1队列里的任务，2线程负责2队列的。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们可能会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务线程永远从双端队列的尾部拿任务执行。
>
> **优点**：充分利用线程进行并行计算，减少线程间的竞争。
> **缺点**：在某些情况下还是会存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗更多的系统资源， 比如创建多个线程和多个双端队列。

----

1、Runnable与Callable的区别；

> 相同点：
>
> 1. 两者都是接口；（废话）
> 2. 两者都可用来编写多线程程序；
> 3. 两者都需要调用Thread.start()启动线程；
>
> 不同点：
>
> 1. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；
> 2. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；

2、synchronized和reentrantlock的实现优缺点；

> **reentrantlock的优点**
>
> - 可以添加多个检控条件, 如果使用synchronized,则只能使用一个. 使用 reentrant locks 可以有多个wait()/notify() 队列. [译注:直接多new 几个ReentrantLock就可以了,不同的场景/条件用不同的ReentrantLock ]
> - 可以控制线程得到锁的顺序,也就是有公平锁(按照进入顺序得到资源),也可以不按照顺就像.synchronized 一样.
> - 可以查看锁的状态, 锁是否被锁上了.
> - 可以查看当前有多少线程再等待锁.
>
> **reentrantlock的缺点**
>
> - 需要使用import 引入相关的Class
> - 不能忘记在finally 模块释放锁,这个看起来比synchronized 丑陋
> - synchronized可以放在方法的定义里面, 而reentrantlock只能放在块里面. 比较起来, synchronized可以减少嵌套

3、用生产者/消费者设计模式进行多线程编程：

a、生产者生产产品，仓库满仓时，产品数量为50；

b、产品数量不为0时，消费者消费产品；

c、生产者生产产品后通知等待的消费者来消费；

d、消费者消费产品后通知生产者进行生产